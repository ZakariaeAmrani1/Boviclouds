import { RequestHandler } from "express";
import {
  ExploitationRecord,
  CreateExploitationInput,
  UpdateExploitationInput,
  ExploitationFilters,
  PaginatedResponse,
  ExploitationListResponse,
  ExploitationResponse,
} from "@shared/exploitation";

// Mock data store - this will simulate a database
let exploitationsData: ExploitationRecord[] = [
  {
    id: "1",
    numero_exploitation: "FR12345678",
    nom_ferme: "Ferme Atlas",
    idbda_onssa: "BDA123456",
    identifiant_responsable: "user1",
    gerant: "Ahmed Benali",
    tel_contact: "+212 6 12 34 56 78",
    email_contact: "contact@fermeatlas.ma",
    eleveur_id: "user2",
    region: "Rabat-Salé-Kénitra",
    province: "Rabat",
    adresse: "Route de Casablanca, Km 15, Rabat",
    location: {
      type: "Point",
      coordinates: [-6.8498, 33.9716],
    },
    sau: 25.5,
    effectif_bovins: 120,
    nb_vaches_lait: 80,
    cooperative: true,
    date_creation: "2020-03-15",
    date_modification: "2024-01-15T10:30:00.000Z",
    createdAt: "2020-03-15T08:00:00.000Z",
    updatedAt: "2024-01-15T10:30:00.000Z",
    createdBy: "admin",
  },
  {
    id: "2",
    numero_exploitation: "FR87654321",
    nom_ferme: "Ferme des Oliviers",
    idbda_onssa: "BDA654321",
    identifiant_responsable: "user3",
    gerant: "Fatima El Alami",
    tel_contact: "+212 6 87 65 43 21",
    email_contact: "contact@fermeoliviers.ma",
    eleveur_id: "user4",
    region: "Casablanca-Settat",
    province: "Casablanca",
    adresse: "Zone industrielle Ain Sebaa, Casablanca",
    location: {
      type: "Point",
      coordinates: [-7.5898, 33.5731],
    },
    sau: 15.0,
    effectif_bovins: 85,
    nb_vaches_lait: 50,
    cooperative: false,
    date_creation: "2019-06-20",
    date_modification: "2024-01-10T14:20:00.000Z",
    createdAt: "2019-06-20T09:00:00.000Z",
    updatedAt: "2024-01-10T14:20:00.000Z",
    createdBy: "manager",
  },
];

// Generate unique ID for new records
const generateId = (): string => {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

// Utility function to apply filters
const applyFilters = (
  data: ExploitationRecord[],
  filters: ExploitationFilters,
): ExploitationRecord[] => {
  return data.filter((record) => {
    if (
      filters.numero_exploitation &&
      !record.numero_exploitation
        .toLowerCase()
        .includes(filters.numero_exploitation.toLowerCase())
    ) {
      return false;
    }
    if (
      filters.nom_ferme &&
      !record.nom_ferme.toLowerCase().includes(filters.nom_ferme.toLowerCase())
    ) {
      return false;
    }
    if (
      filters.idbda_onssa &&
      !record.idbda_onssa
        .toLowerCase()
        .includes(filters.idbda_onssa.toLowerCase())
    ) {
      return false;
    }
    if (
      filters.gerant &&
      !record.gerant.toLowerCase().includes(filters.gerant.toLowerCase())
    ) {
      return false;
    }
    if (filters.region && record.region !== filters.region) {
      return false;
    }
    if (filters.province && record.province !== filters.province) {
      return false;
    }
    if (
      filters.cooperative !== undefined &&
      record.cooperative !== filters.cooperative
    ) {
      return false;
    }
    if (
      filters.identifiant_responsable &&
      record.identifiant_responsable !== filters.identifiant_responsable
    ) {
      return false;
    }
    if (filters.createdBy && record.createdBy !== filters.createdBy) {
      return false;
    }
    return true;
  });
};

// GET /api/exploitation - Get all exploitations with filtering and pagination
export const getExploitations: RequestHandler = (req, res) => {
  try {
    const {
      page = "1",
      limit = "10",
      numero_exploitation,
      nom_ferme,
      idbda_onssa,
      gerant,
      region,
      province,
      cooperative,
      identifiant_responsable,
      createdBy,
    } = req.query;

    const pageNum = parseInt(page as string);
    const limitNum = parseInt(limit as string);

    const filters: ExploitationFilters = {
      numero_exploitation: numero_exploitation as string,
      nom_ferme: nom_ferme as string,
      idbda_onssa: idbda_onssa as string,
      gerant: gerant as string,
      region: region as string,
      province: province as string,
      cooperative: cooperative ? cooperative === "true" : undefined,
      identifiant_responsable: identifiant_responsable as string,
      createdBy: createdBy as string,
    };

    const filteredData = applyFilters(exploitationsData, filters);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;
    const paginatedData = filteredData.slice(startIndex, endIndex);

    const response: PaginatedResponse<ExploitationRecord> = {
      data: paginatedData,
      total: filteredData.length,
      page: pageNum,
      limit: limitNum,
      totalPages: Math.ceil(filteredData.length / limitNum),
    };

    const result: ExploitationListResponse = {
      success: true,
      data: response,
    };

    res.json(result);
  } catch (error) {
    console.error("Error getting exploitations:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// GET /api/exploitation/:id - Get a single exploitation by ID
export const getExploitationById: RequestHandler = (req, res) => {
  try {
    const { id } = req.params;
    const exploitation = exploitationsData.find((e) => e.id === id);

    if (!exploitation) {
      return res.status(404).json({
        success: false,
        message: "Exploitation non trouvée",
      });
    }

    const result: ExploitationResponse = {
      success: true,
      data: exploitation,
    };

    res.json(result);
  } catch (error) {
    console.error("Error getting exploitation by ID:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// POST /api/exploitation - Create a new exploitation
export const createExploitation: RequestHandler = (req, res) => {
  try {
    const input: CreateExploitationInput = req.body;

    // Check for duplicate numero_exploitation
    const existingExploitation = exploitationsData.find(
      (e) => e.numero_exploitation === input.numero_exploitation,
    );

    if (existingExploitation) {
      return res.status(400).json({
        success: false,
        message: "Ce numéro d'exploitation existe déjà",
      });
    }

    const newExploitation: ExploitationRecord = {
      id: generateId(),
      ...input,
      date_modification: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    exploitationsData.push(newExploitation);

    const result: ExploitationResponse = {
      success: true,
      data: newExploitation,
    };

    res.status(201).json(result);
  } catch (error) {
    console.error("Error creating exploitation:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// PUT /api/exploitation/:id - Update an existing exploitation
export const updateExploitation: RequestHandler = (req, res) => {
  try {
    const { id } = req.params;
    const input: UpdateExploitationInput = req.body;

    const exploitationIndex = exploitationsData.findIndex((e) => e.id === id);

    if (exploitationIndex === -1) {
      return res.status(404).json({
        success: false,
        message: "Exploitation non trouvée",
      });
    }

    // Check for duplicate numero_exploitation (excluding current record)
    if (input.numero_exploitation) {
      const existingExploitation = exploitationsData.find(
        (e) =>
          e.numero_exploitation === input.numero_exploitation && e.id !== id,
      );

      if (existingExploitation) {
        return res.status(400).json({
          success: false,
          message: "Ce numéro d'exploitation existe déjà",
        });
      }
    }

    const updatedExploitation: ExploitationRecord = {
      ...exploitationsData[exploitationIndex],
      ...input,
      date_modification: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    exploitationsData[exploitationIndex] = updatedExploitation;

    const result: ExploitationResponse = {
      success: true,
      data: updatedExploitation,
    };

    res.json(result);
  } catch (error) {
    console.error("Error updating exploitation:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// DELETE /api/exploitation/:id - Delete an exploitation
export const deleteExploitation: RequestHandler = (req, res) => {
  try {
    const { id } = req.params;
    const exploitationIndex = exploitationsData.findIndex((e) => e.id === id);

    if (exploitationIndex === -1) {
      return res.status(404).json({
        success: false,
        message: "Exploitation non trouvée",
      });
    }

    exploitationsData.splice(exploitationIndex, 1);

    res.json({
      success: true,
      message: "Exploitation supprimée avec succès",
    });
  } catch (error) {
    console.error("Error deleting exploitation:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// GET /api/exploitation/stats - Get exploitation statistics
export const getExploitationStats: RequestHandler = (req, res) => {
  try {
    const totalExploitations = exploitationsData.length;
    const totalSAU = exploitationsData.reduce((sum, e) => sum + e.sau, 0);
    const totalBovins = exploitationsData.reduce(
      (sum, e) => sum + e.effectif_bovins,
      0,
    );
    const totalVachesLait = exploitationsData.reduce(
      (sum, e) => sum + e.nb_vaches_lait,
      0,
    );
    const cooperativeCount = exploitationsData.filter(
      (e) => e.cooperative,
    ).length;

    // Get exploitations created this month
    const currentDate = new Date();
    const currentMonth = currentDate.getMonth();
    const currentYear = currentDate.getFullYear();
    const thisMonth = exploitationsData.filter((e) => {
      const createdDate = new Date(e.createdAt);
      return (
        createdDate.getMonth() === currentMonth &&
        createdDate.getFullYear() === currentYear
      );
    }).length;

    // Get exploitations created this year
    const thisYear = exploitationsData.filter((e) => {
      const createdDate = new Date(e.createdAt);
      return createdDate.getFullYear() === currentYear;
    }).length;

    // Get top regions
    const regionCounts: Record<string, number> = {};
    exploitationsData.forEach((e) => {
      regionCounts[e.region] = (regionCounts[e.region] || 0) + 1;
    });
    const topRegions = Object.entries(regionCounts)
      .map(([region, count]) => ({ region, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    // Get top provinces
    const provinceCounts: Record<string, number> = {};
    exploitationsData.forEach((e) => {
      provinceCounts[e.province] = (provinceCounts[e.province] || 0) + 1;
    });
    const topProvinces = Object.entries(provinceCounts)
      .map(([province, count]) => ({ province, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    const stats = {
      total: totalExploitations,
      thisMonth,
      thisYear,
      totalSAU,
      totalBovins,
      totalVachesLait,
      cooperativeCount,
      topRegions,
      topProvinces,
    };

    res.json({
      success: true,
      data: stats,
    });
  } catch (error) {
    console.error("Error getting exploitation stats:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// GET /api/exploitation/export - Export exploitations data
export const exportExploitations: RequestHandler = (req, res) => {
  try {
    const { format = "csv" } = req.query;

    // For now, return JSON data
    // In a real implementation, you would generate CSV/Excel files
    res.json({
      success: true,
      data: exploitationsData,
      message: `Export ${format} functionality would be implemented here`,
    });
  } catch (error) {
    console.error("Error exporting exploitations:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};
