import { RequestHandler } from "express";
import {
  ExploitationRecord,
  CreateExploitationInput,
  UpdateExploitationInput,
  ExploitationFilters,
  PaginatedResponse,
  ExploitationListResponse,
  ExploitationResponse,
} from "@shared/exploitation";
import axios from "axios";

// Mock data store - this will simulate a database
let exploitationsData: ExploitationRecord[] = [];

// Generate unique ID for new records
const generateId = (): string => {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

// Utility function to apply filters
const applyFilters = (
  data: ExploitationRecord[],
  filters: ExploitationFilters,
): ExploitationRecord[] => {
  return data.filter((record) => {
    if (
      filters.numero_exploitation &&
      !record.numero_exploitation
        .toLowerCase()
        .includes(filters.numero_exploitation.toLowerCase())
    ) {
      return false;
    }
    if (
      filters.nom_ferme &&
      !record.nom_ferme.toLowerCase().includes(filters.nom_ferme.toLowerCase())
    ) {
      return false;
    }
    if (
      filters.idbda_onssa &&
      !record.idbda_onssa
        .toLowerCase()
        .includes(filters.idbda_onssa.toLowerCase())
    ) {
      return false;
    }
    if (
      filters.gerant &&
      !record.gerant.toLowerCase().includes(filters.gerant.toLowerCase())
    ) {
      return false;
    }
    if (filters.region && record.region !== filters.region) {
      return false;
    }
    if (filters.province && record.province !== filters.province) {
      return false;
    }
    if (
      filters.cooperative !== undefined &&
      record.cooperative !== filters.cooperative
    ) {
      return false;
    }
    if (
      filters.identifiant_responsable &&
      record.identifiant_responsable !== filters.identifiant_responsable
    ) {
      return false;
    }
    if (filters.createdBy && record.createdBy !== filters.createdBy) {
      return false;
    }
    return true;
  });
};

// GET /api/exploitation - Get all exploitations with filtering and pagination
export const getExploitations: RequestHandler = async (req, res) => {
  exploitationsData = [];
  const apiUrl = process.env.SERVER_API_URL;
  try {
    const {
      page = "1",
      limit = "10",
      numero_exploitation,
      nom_ferme,
      idbda_onssa,
      gerant,
      region,
      province,
      cooperative,
      identifiant_responsable,
      createdBy,
      token,
    } = req.query;

    const data = await axios.get(`${apiUrl}exploitations`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    data.data.map((data) => {
      exploitationsData.push({
        id: data._id,
        numero_exploitation: data.numero_exploitation,
        nom_ferme: data.nom_ferme,
        idbda_onssa: data.idbda_onssa,
        identifiant_responsable: data.identifiant_responsable._id,
        gerant: data.gerant,
        tel_contact: data.tel_contact,
        email_contact: data.email_contact,
        eleveur_id: data.eleveur_id._id,
        region: data.region,
        province: data.province,
        adresse: data.adresse,
        location: {
          type: data.location.type,
          coordinates: [
            data.location.coordinates[0],
            data.location.coordinates[0],
          ],
        },
        sau: data.sau,
        effectif_bovins: data.effectif_bovins,
        nb_vaches_lait: data.nb_vaches_lait,
        cooperative: data.cooperative,
        date_creation: data.date_creation,
        date_modification: data.date_modification,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
        createdBy: "Administrateur",
      });
    });

    const pageNum = parseInt(page as string);
    const limitNum = parseInt(limit as string);

    const filters: ExploitationFilters = {
      numero_exploitation: numero_exploitation as string,
      nom_ferme: nom_ferme as string,
      idbda_onssa: idbda_onssa as string,
      gerant: gerant as string,
      region: region as string,
      province: province as string,
      cooperative: cooperative ? cooperative === "true" : undefined,
      identifiant_responsable: identifiant_responsable as string,
      createdBy: createdBy as string,
    };

    const filteredData = applyFilters(exploitationsData, filters);
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = startIndex + limitNum;
    const paginatedData = filteredData.slice(startIndex, endIndex);

    const response: PaginatedResponse<ExploitationRecord> = {
      data: paginatedData,
      total: filteredData.length,
      page: pageNum,
      limit: limitNum,
      totalPages: Math.ceil(filteredData.length / limitNum),
    };

    const result: ExploitationListResponse = {
      success: true,
      data: response,
    };

    res.json(result);
  } catch (error) {
    console.error("Error getting exploitations:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// GET /api/exploitation/:id - Get a single exploitation by ID
export const getExploitationById: RequestHandler = (req, res) => {
  try {
    const { id } = req.params;
    const exploitation = exploitationsData.find((e) => e.id === id);

    if (!exploitation) {
      return res.status(404).json({
        success: false,
        message: "Exploitation non trouvée",
      });
    }

    const result: ExploitationResponse = {
      success: true,
      data: exploitation,
    };

    res.json(result);
  } catch (error) {
    console.error("Error getting exploitation by ID:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// POST /api/exploitation - Create a new exploitation
export const createExploitation: RequestHandler = async (req, res) => {
  const apiUrl = process.env.SERVER_API_URL;
  try {
    const input: CreateExploitationInput = req.body;

    const data = await axios.post(
      `${apiUrl}exploitations`,
      {
        numero_exploitation: input.numero_exploitation,
        nom_ferme: input.nom_ferme,
        idbda_onssa: input.idbda_onssa,
        identifiant_responsable: input.identifiant_responsable,
        eleveur_id: input.eleveur_id,
        region: input.region,
        province: input.province,
        adresse: input.adresse,
        sau: input.sau,
        effectif_bovins: input.effectif_bovins,
        nb_vaches_lait: input.nb_vaches_lait,
        gerant: input.gerant,
        tel_contact: input.tel_contact,
        email_contact: input.email_contact,
        cooperative: input.cooperative,
        longitude: input.location.coordinates?.[0],
        latitude: input.location.coordinates?.[1],
      },
      {
        headers: {
          Authorization: `Bearer ${input.token}`,
        },
      },
    );

    // Check for duplicate numero_exploitation
    const existingExploitation = exploitationsData.find(
      (e) => e.numero_exploitation === input.numero_exploitation,
    );

    if (existingExploitation) {
      return res.status(400).json({
        success: false,
        message: "Ce numéro d'exploitation existe déjà",
      });
    }

    const newExploitation: ExploitationRecord = {
      id: generateId(),
      ...input,
      date_modification: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    exploitationsData.push(newExploitation);

    const result: ExploitationResponse = {
      success: true,
      data: newExploitation,
    };

    res.status(201).json(result);
  } catch (error) {
    console.error("Error creating exploitation:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// PUT /api/exploitation/:id - Update an existing exploitation
export const updateExploitation: RequestHandler = async (req, res) => {
  const apiUrl = process.env.SERVER_API_URL;
  try {
    const { id } = req.params;
    const input: UpdateExploitationInput = req.body;
    const data = await axios.patch(
      `${apiUrl}exploitations/${id}`,
      {
        numero_exploitation: input.numero_exploitation,
        nom_ferme: input.nom_ferme,
        idbda_onssa: input.idbda_onssa,
        identifiant_responsable: input.identifiant_responsable,
        eleveur_id: input.eleveur_id,
        region: input.region,
        province: input.province,
        adresse: input.adresse,
        sau: input.sau,
        effectif_bovins: input.effectif_bovins,
        nb_vaches_lait: input.nb_vaches_lait,
        gerant: input.gerant,
        tel_contact: input.tel_contact,
        email_contact: input.email_contact,
        cooperative: input.cooperative,
        longitude: input.location.coordinates?.[0],
        latitude: input.location.coordinates?.[1],
      },
      {
        headers: {
          Authorization: `Bearer ${input.token}`,
        },
      },
    );
    const exploitationIndex = exploitationsData.findIndex((e) => e.id === id);

    if (exploitationIndex === -1) {
      return res.status(404).json({
        success: false,
        message: "Exploitation non trouvée",
      });
    }

    // Check for duplicate numero_exploitation (excluding current record)
    if (input.numero_exploitation) {
      const existingExploitation = exploitationsData.find(
        (e) =>
          e.numero_exploitation === input.numero_exploitation && e.id !== id,
      );

      if (existingExploitation) {
        return res.status(400).json({
          success: false,
          message: "Ce numéro d'exploitation existe déjà",
        });
      }
    }

    const updatedExploitation: ExploitationRecord = {
      ...exploitationsData[exploitationIndex],
      ...input,
      date_modification: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    exploitationsData[exploitationIndex] = updatedExploitation;

    const result: ExploitationResponse = {
      success: true,
      data: updatedExploitation,
    };

    res.json(result);
  } catch (error) {
    console.error("Error updating exploitation:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// DELETE /api/exploitation/:id - Delete an exploitation
export const deleteExploitation: RequestHandler = (req, res) => {
  try {
    const { id } = req.params;
    const exploitationIndex = exploitationsData.findIndex((e) => e.id === id);

    if (exploitationIndex === -1) {
      return res.status(404).json({
        success: false,
        message: "Exploitation non trouvée",
      });
    }

    exploitationsData.splice(exploitationIndex, 1);

    res.json({
      success: true,
      message: "Exploitation supprimée avec succès",
    });
  } catch (error) {
    console.error("Error deleting exploitation:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// GET /api/exploitation/stats - Get exploitation statistics
export const getExploitationStats: RequestHandler = (req, res) => {
  try {
    const totalExploitations = exploitationsData.length;
    const totalSAU = exploitationsData.reduce((sum, e) => sum + e.sau, 0);
    const totalBovins = exploitationsData.reduce(
      (sum, e) => sum + e.effectif_bovins,
      0,
    );
    const totalVachesLait = exploitationsData.reduce(
      (sum, e) => sum + e.nb_vaches_lait,
      0,
    );
    const cooperativeCount = exploitationsData.filter(
      (e) => e.cooperative,
    ).length;

    // Get exploitations created this month
    const currentDate = new Date();
    const currentMonth = currentDate.getMonth();
    const currentYear = currentDate.getFullYear();
    const thisMonth = exploitationsData.filter((e) => {
      const createdDate = new Date(e.createdAt);
      return (
        createdDate.getMonth() === currentMonth &&
        createdDate.getFullYear() === currentYear
      );
    }).length;

    // Get exploitations created this year
    const thisYear = exploitationsData.filter((e) => {
      const createdDate = new Date(e.createdAt);
      return createdDate.getFullYear() === currentYear;
    }).length;

    // Get top regions
    const regionCounts: Record<string, number> = {};
    exploitationsData.forEach((e) => {
      regionCounts[e.region] = (regionCounts[e.region] || 0) + 1;
    });
    const topRegions = Object.entries(regionCounts)
      .map(([region, count]) => ({ region, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    // Get top provinces
    const provinceCounts: Record<string, number> = {};
    exploitationsData.forEach((e) => {
      provinceCounts[e.province] = (provinceCounts[e.province] || 0) + 1;
    });
    const topProvinces = Object.entries(provinceCounts)
      .map(([province, count]) => ({ province, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    const stats = {
      total: totalExploitations,
      thisMonth,
      thisYear,
      totalSAU,
      totalBovins,
      totalVachesLait,
      cooperativeCount,
      topRegions,
      topProvinces,
    };

    res.json({
      success: true,
      data: stats,
    });
  } catch (error) {
    console.error("Error getting exploitation stats:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};

// GET /api/exploitation/export - Export exploitations data
export const exportExploitations: RequestHandler = (req, res) => {
  try {
    const { format = "csv" } = req.query;

    // For now, return JSON data
    // In a real implementation, you would generate CSV/Excel files
    res.json({
      success: true,
      data: exploitationsData,
      message: `Export ${format} functionality would be implemented here`,
    });
  } catch (error) {
    console.error("Error exporting exploitations:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur",
    });
  }
};
