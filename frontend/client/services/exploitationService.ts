import {
  ExploitationRecord,
  CreateExploitationInput,
  UpdateExploitationInput,
  ExploitationFilters,
  PaginationParams,
  PaginatedResponse,
  ExploitationStats,
  ExploitationResponse,
  ExploitationListResponse,
  User,
  UsersListResponse,
} from "@shared/exploitation";

const API_BASE_URL = "/api/exploitation";

export class ExploitationService {
  /**
   * Get all exploitation records with optional filtering and pagination
   */
  static async getAll(
    filters: ExploitationFilters = {},
    pagination: PaginationParams = { page: 1, limit: 10 },
  ): Promise<PaginatedResponse<ExploitationRecord>> {
    const params = new URLSearchParams();

    // Add pagination params
    params.append("page", pagination.page.toString());
    params.append("limit", pagination.limit.toString());

    // Add filter params
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null && value !== "") {
        params.append(key, value.toString());
      }
    });

    const response = await fetch(`${API_BASE_URL}?${params.toString()}`);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result: ExploitationListResponse = await response.json();

    if (!result.success || !result.data) {
      throw new Error(
        result.message || "Erreur lors de la récupération des exploitations",
      );
    }

    return result.data;
  }

  /**
   * Get a single exploitation record by ID
   */
  static async getById(id: string): Promise<ExploitationRecord> {
    const response = await fetch(`${API_BASE_URL}/${id}`);

    if (!response.ok) {
      if (response.status === 404) {
        throw new Error("Exploitation non trouvée");
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result: ExploitationResponse = await response.json();

    if (!result.success || !result.data) {
      throw new Error(
        result.message || "Erreur lors de la récupération de l'exploitation",
      );
    }

    return result.data;
  }

  /**
   * Create a new exploitation record
   */
  static async create(
    input: CreateExploitationInput,
  ): Promise<ExploitationRecord> {
    const response = await fetch(API_BASE_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(input),
    });

    if (!response.ok) {
      const errorResult = await response.json();
      throw new Error(
        errorResult.message || `HTTP error! status: ${response.status}`,
      );
    }

    const result: ExploitationResponse = await response.json();

    if (!result.success || !result.data) {
      throw new Error(
        result.message || "Erreur lors de la création de l'exploitation",
      );
    }

    return result.data;
  }

  /**
   * Update an existing exploitation record
   */
  static async update(
    id: string,
    input: UpdateExploitationInput,
  ): Promise<ExploitationRecord> {
    const response = await fetch(`${API_BASE_URL}/${id}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(input),
    });

    if (!response.ok) {
      const errorResult = await response.json();
      throw new Error(
        errorResult.message || `HTTP error! status: ${response.status}`,
      );
    }

    const result: ExploitationResponse = await response.json();

    if (!result.success || !result.data) {
      throw new Error(
        result.message || "Erreur lors de la mise à jour de l'exploitation",
      );
    }

    return result.data;
  }

  /**
   * Delete an exploitation record
   */
  static async delete(id: string): Promise<void> {
    const response = await fetch(`${API_BASE_URL}/${id}`, {
      method: "DELETE",
    });

    if (!response.ok) {
      const errorResult = await response.json();
      throw new Error(
        errorResult.message || `HTTP error! status: ${response.status}`,
      );
    }

    const result = await response.json();

    if (!result.success) {
      throw new Error(
        result.message || "Erreur lors de la suppression de l'exploitation",
      );
    }
  }

  /**
   * Get exploitation statistics
   */
  static async getStats(): Promise<ExploitationStats> {
    const response = await fetch(`${API_BASE_URL}/stats`);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();

    if (!result.success || !result.data) {
      throw new Error(
        result.message || "Erreur lors de la récupération des statistiques",
      );
    }

    return result.data;
  }

  /**
   * Search exploitations by numero_exploitation (quick search)
   */
  static async searchByNumeroExploitation(numeroExploitation: string): Promise<ExploitationRecord[]> {
    if (!numeroExploitation.trim()) {
      return [];
    }

    const filters: ExploitationFilters = { numero_exploitation: numeroExploitation.trim() };
    const result = await this.getAll(filters, { page: 1, limit: 10 });
    return result.data;
  }

  /**
   * Search exploitations by nom_ferme
   */
  static async searchByNomFerme(
    nomFerme: string,
  ): Promise<ExploitationRecord[]> {
    if (!nomFerme.trim()) {
      return [];
    }

    const filters: ExploitationFilters = { nom_ferme: nomFerme.trim() };
    const result = await this.getAll(filters, { page: 1, limit: 10 });
    return result.data;
  }

  /**
   * Search exploitations by region
   */
  static async searchByRegion(
    region: string,
  ): Promise<ExploitationRecord[]> {
    if (!region.trim()) {
      return [];
    }

    const filters: ExploitationFilters = { region: region.trim() };
    const result = await this.getAll(filters, { page: 1, limit: 10 });
    return result.data;
  }

  /**
   * Search exploitations by province
   */
  static async searchByProvince(
    province: string,
  ): Promise<ExploitationRecord[]> {
    if (!province.trim()) {
      return [];
    }

    const filters: ExploitationFilters = { province: province.trim() };
    const result = await this.getAll(filters, { page: 1, limit: 10 });
    return result.data;
  }

  /**
   * Export exploitation data
   */
  static async export(
    filters: ExploitationFilters = {},
    format: "csv" | "excel" = "csv",
  ): Promise<Blob> {
    const params = new URLSearchParams();

    // Add filter params
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null && value !== "") {
        params.append(key, value.toString());
      }
    });

    params.append("format", format);

    const response = await fetch(`${API_BASE_URL}/export?${params.toString()}`);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return response.blob();
  }

  /**
   * Check if numero_exploitation already exists (for validation)
   */
  static async checkDuplicateNumeroExploitation(
    numeroExploitation: string,
    excludeId?: string,
  ): Promise<boolean> {
    try {
      const filters: ExploitationFilters = {
        numero_exploitation: numeroExploitation.trim(),
      };
      const result = await this.getAll(filters, { page: 1, limit: 10 });

      if (excludeId) {
        // Filter out the record being edited
        const filteredRecords = result.data.filter(
          (record) => record.id !== excludeId,
        );
        return filteredRecords.length > 0;
      }

      return result.data.length > 0;
    } catch {
      // If there's an error, assume no duplicate to be safe
      return false;
    }
  }

  /**
   * Check if idbda_onssa already exists (for validation)
   */
  static async checkDuplicateIdbdaOnssa(
    idbdaOnssa: string,
    excludeId?: string,
  ): Promise<boolean> {
    try {
      const filters: ExploitationFilters = {
        idbda_onssa: idbdaOnssa.trim(),
      };
      const result = await this.getAll(filters, { page: 1, limit: 10 });

      if (excludeId) {
        // Filter out the record being edited
        const filteredRecords = result.data.filter(
          (record) => record.id !== excludeId,
        );
        return filteredRecords.length > 0;
      }

      return result.data.length > 0;
    } catch {
      // If there's an error, assume no duplicate to be safe
      return false;
    }
  }

  /**
   * Get recent exploitations
   */
  static async getRecent(limit: number = 5): Promise<ExploitationRecord[]> {
    const result = await this.getAll({}, { page: 1, limit });
    return result.data;
  }

  /**
   * Get all users for dropdown menus
   */
  static async getUsers(): Promise<User[]> {
    const token = localStorage.getItem("access_token");
    const response = await fetch("/api/utilisateur", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ token }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result: UsersListResponse = await response.json();

    if (!result.success || !result.data) {
      throw new Error(
        result.message || "Erreur lors de la récupération des utilisateurs",
      );
    }

    return result.data;
  }

  /**
   * Get users by role (for filtering)
   */
  static async getUsersByRole(role?: string): Promise<User[]> {
    const users = await this.getUsers();

    if (!role) {
      return users;
    }

    return users.filter((user) => user.role === role);
  }

  /**
   * Bulk operations helper
   */
  static async bulkDelete(ids: string[]): Promise<void> {
    const deletePromises = ids.map((id) => this.delete(id));
    await Promise.all(deletePromises);
  }

  /**
   * Get exploitations by date range
   */
  static async getByDateRange(
    startDate: string,
    endDate: string,
  ): Promise<ExploitationRecord[]> {
    // Note: This would need backend support for date range filtering
    // For now, we'll get all and filter client-side (not ideal for production)
    const result = await this.getAll({}, { page: 1, limit: 1000 });

    return result.data.filter((record) => {
      const createdDate = new Date(record.createdAt);
      const start = new Date(startDate);
      const end = new Date(endDate);
      return createdDate >= start && createdDate <= end;
    });
  }

  /**
   * Get monthly statistics for a given year
   */
  static async getMonthlyStats(year: number): Promise<Record<string, number>> {
    const startDate = `${year}-01-01`;
    const endDate = `${year}-12-31`;
    const records = await this.getByDateRange(startDate, endDate);

    const monthlyStats: Record<string, number> = {};

    for (let month = 1; month <= 12; month++) {
      const monthKey = month.toString().padStart(2, "0");
      monthlyStats[monthKey] = records.filter((record) => {
        const createdDate = new Date(record.createdAt);
        return createdDate.getMonth() + 1 === month;
      }).length;
    }

    return monthlyStats;
  }

  /**
   * Get exploitations by region (for analytics)
   */
  static async getByRegion(region: string): Promise<ExploitationRecord[]> {
    const filters: ExploitationFilters = { region };
    const result = await this.getAll(filters, { page: 1, limit: 100 });
    return result.data;
  }

  /**
   * Get available regions (for dropdown population)
   */
  static async getAvailableRegions(): Promise<string[]> {
    // This would ideally come from the backend, but for now we'll get all records
    // and extract unique regions
    const result = await this.getAll({}, { page: 1, limit: 1000 });
    const regions = [...new Set(result.data.map(record => record.region))];
    return regions.sort();
  }

  /**
   * Get available provinces (for dropdown population)
   */
  static async getAvailableProvinces(): Promise<string[]> {
    // This would ideally come from the backend, but for now we'll get all records
    // and extract unique provinces
    const result = await this.getAll({}, { page: 1, limit: 1000 });
    const provinces = [...new Set(result.data.map(record => record.province))];
    return provinces.sort();
  }

  /**
   * Get exploitations by cooperative status
   */
  static async getByCooperativeStatus(cooperative: boolean): Promise<ExploitationRecord[]> {
    const filters: ExploitationFilters = { cooperative };
    const result = await this.getAll(filters, { page: 1, limit: 100 });
    return result.data;
  }

  /**
   * Get exploitation statistics by region
   */
  static async getStatsByRegion(): Promise<Record<string, {
    count: number;
    totalSAU: number;
    totalBovins: number;
    totalVachesLait: number;
    cooperativeCount: number;
  }>> {
    const result = await this.getAll({}, { page: 1, limit: 1000 });
    const statsByRegion: Record<string, any> = {};

    result.data.forEach(record => {
      if (!statsByRegion[record.region]) {
        statsByRegion[record.region] = {
          count: 0,
          totalSAU: 0,
          totalBovins: 0,
          totalVachesLait: 0,
          cooperativeCount: 0,
        };
      }

      const regionStats = statsByRegion[record.region];
      regionStats.count++;
      regionStats.totalSAU += record.sau;
      regionStats.totalBovins += record.effectif_bovins;
      regionStats.totalVachesLait += record.nb_vaches_lait;
      if (record.cooperative) {
        regionStats.cooperativeCount++;
      }
    });

    return statsByRegion;
  }

  /**
   * Get nearby exploitations based on coordinates
   */
  static async getNearbyExploitations(
    coordinates: [number, number],
    radiusKm: number = 50,
  ): Promise<ExploitationRecord[]> {
    // This would ideally be done on the backend with spatial queries
    // For now, we'll get all and filter client-side (not ideal for production)
    const result = await this.getAll({}, { page: 1, limit: 1000 });

    const [targetLng, targetLat] = coordinates;

    return result.data.filter(record => {
      const [recordLng, recordLat] = record.location.coordinates;
      
      // Calculate distance using Haversine formula (simplified)
      const R = 6371; // Earth's radius in km
      const dLat = (recordLat - targetLat) * Math.PI / 180;
      const dLng = (recordLng - targetLng) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(targetLat * Math.PI / 180) * Math.cos(recordLat * Math.PI / 180) * 
        Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      const distance = R * c;

      return distance <= radiusKm;
    });
  }

  /**
   * Validate exploitation location coordinates
   */
  static async validateLocation(coordinates: [number, number]): Promise<{
    valid: boolean;
    inMorocco: boolean;
    region?: string;
    province?: string;
  }> {
    const [lng, lat] = coordinates;
    
    // Basic coordinate validation
    const valid = lng >= -180 && lng <= 180 && lat >= -90 && lat <= 90;
    
    // Morocco bounds check
    const inMorocco = lng >= -17.2 && lng <= -0.99 && lat >= 21.42 && lat <= 35.92;

    // In a real implementation, this would use a geocoding service
    // to determine the actual region/province
    return {
      valid,
      inMorocco,
      // These would come from a geocoding service
      region: undefined,
      province: undefined,
    };
  }
}
