import { z } from "zod";
import {
  CreateExploitationSchema as BaseCreateSchema,
  UpdateExploitationSchema as BaseUpdateSchema,
  MOROCCAN_REGIONS,
  PROVINCE_BY_REGION,
} from "@shared/exploitation";

// Custom validation messages in French
const requiredMsg = "Ce champ est requis";
const invalidEmailMsg = "Format d'email invalide";
const invalidPhoneMsg = "Format de téléphone invalide";
const invalidNumExploitationMsg = "Format de numéro d'exploitation invalide";

// Numéro exploitation validation pattern (FR prefix + 8 digits)
const NUM_EXPLOITATION_PATTERN = /^FR\d{8}$/;

// Phone number validation pattern (Moroccan format)
const PHONE_PATTERN = /^(\+212|0)[5-7]\d{8}$/;

// Email validation
const emailValidation = z
  .string()
  .min(1, requiredMsg)
  .email(invalidEmailMsg)
  .toLowerCase();

// Phone validation
const phoneValidation = z
  .string()
  .min(1, requiredMsg)
  .regex(PHONE_PATTERN, invalidPhoneMsg);

// Numéro exploitation validation
const numeroExploitationValidation = z
  .string()
  .min(1, requiredMsg)
  .regex(NUM_EXPLOITATION_PATTERN, invalidNumExploitationMsg)
  .transform((val) => val.toUpperCase());

// Name validation (for farm name and gerant)
const nameValidation = z
  .string()
  .min(1, requiredMsg)
  .min(2, "Le nom doit contenir au moins 2 caractères")
  .max(100, "Le nom ne peut pas dépasser 100 caractères")
  .regex(/^[A-Za-zÀ-ÿ\s\-'.,0-9]+$/, "Le nom contient des caractères invalides");

// Address validation
const addressValidation = z
  .string()
  .min(1, requiredMsg)
  .min(5, "L'adresse doit contenir au moins 5 caractères")
  .max(200, "L'adresse ne peut pas dépasser 200 caractères");

// Region validation
const regionValidation = z
  .string()
  .min(1, requiredMsg)
  .refine((val) => MOROCCAN_REGIONS.includes(val), {
    message: "Région non valide",
  });

// Province validation
const provinceValidation = (region?: string) =>
  z
    .string()
    .min(1, requiredMsg)
    .refine(
      (val) => {
        if (!region) return true;
        const provinces = PROVINCE_BY_REGION[region];
        return provinces && provinces.includes(val);
      },
      {
        message: "Province non valide pour cette région",
      }
    );

// Location coordinates validation
const locationValidation = z.object({
  type: z.literal("Point"),
  coordinates: z
    .array(z.number())
    .length(2)
    .refine(
      ([lng, lat]) => lng >= -180 && lng <= 180 && lat >= -90 && lat <= 90,
      {
        message: "Coordonnées géographiques invalides",
      }
    )
    .refine(
      ([lng, lat]) => lng >= -17.2 && lng <= -0.99 && lat >= 21.42 && lat <= 35.92,
      {
        message: "Les coordonnées doivent être situées au Maroc",
      }
    ),
});

// Numeric validations
const sauValidation = z
  .number()
  .min(0, "La SAU doit être positive")
  .max(10000, "La SAU ne peut pas dépasser 10,000 hectares");

const effectifBovinsValidation = z
  .number()
  .min(0, "L'effectif de bovins doit être positif")
  .max(100000, "L'effectif ne peut pas dépasser 100,000 têtes");

const nbVachesLaitValidation = z
  .number()
  .min(0, "Le nombre de vaches laitières doit être positif")
  .max(50000, "Le nombre ne peut pas dépasser 50,000 têtes");

// Date validation
const dateCreationValidation = z
  .string()
  .min(1, requiredMsg)
  .refine((date) => {
    const parsed = new Date(date);
    return !isNaN(parsed.getTime());
  }, "Date invalide")
  .refine((date) => {
    const parsed = new Date(date);
    const now = new Date();
    return parsed <= now;
  }, "La date ne peut pas être dans le futur");

// Step 1 validation (Basic Info)
export const Step1ValidationSchema = z.object({
  numero_exploitation: numeroExploitationValidation,
  nom_ferme: nameValidation,
  idbda_onssa: z
    .string()
    .min(1, requiredMsg)
    .min(5, "L'ID BDA ONSSA doit contenir au moins 5 caractères")
    .max(20, "L'ID BDA ONSSA ne peut pas dépasser 20 caractères"),
});

// Step 2 validation (Responsible Persons)
export const Step2ValidationSchema = z.object({
  identifiant_responsable: z.string().min(1, "Le responsable est requis"),
  gerant: nameValidation,
  eleveur_id: z.string().min(1, "L'éleveur est requis"),
});

// Step 3 validation (Contact & Location)
export const Step3ValidationSchema = z
  .object({
    tel_contact: phoneValidation,
    email_contact: emailValidation,
    region: regionValidation,
    province: z.string().min(1, requiredMsg),
    adresse: addressValidation,
  })
  .superRefine((data, ctx) => {
    // Validate province based on region
    const provinces = PROVINCE_BY_REGION[data.region];
    if (provinces && !provinces.includes(data.province)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Province non valide pour cette région",
        path: ["province"],
      });
    }
  });

// Step 4 validation (Location Coordinates)
export const Step4ValidationSchema = z.object({
  location: locationValidation,
});

// Step 5 validation (Farm Details)
export const Step5ValidationSchema = z
  .object({
    sau: sauValidation,
    effectif_bovins: effectifBovinsValidation,
    nb_vaches_lait: nbVachesLaitValidation,
    cooperative: z.boolean(),
    date_creation: dateCreationValidation,
  })
  .superRefine((data, ctx) => {
    // Validate that nb_vaches_lait <= effectif_bovins
    if (data.nb_vaches_lait > data.effectif_bovins) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Le nombre de vaches laitières ne peut pas dépasser l'effectif total",
        path: ["nb_vaches_lait"],
      });
    }
  });

// Full create exploitation validation schema
export const CreateExploitationValidationSchema = z
  .object({
    numero_exploitation: numeroExploitationValidation,
    nom_ferme: nameValidation,
    idbda_onssa: z
      .string()
      .min(1, requiredMsg)
      .min(5, "L'ID BDA ONSSA doit contenir au moins 5 caractères")
      .max(20, "L'ID BDA ONSSA ne peut pas dépasser 20 caractères"),
    identifiant_responsable: z.string().min(1, "Le responsable est requis"),
    gerant: nameValidation,
    tel_contact: phoneValidation,
    email_contact: emailValidation,
    eleveur_id: z.string().min(1, "L'éleveur est requis"),
    region: regionValidation,
    province: z.string().min(1, requiredMsg),
    adresse: addressValidation,
    location: locationValidation,
    sau: sauValidation,
    effectif_bovins: effectifBovinsValidation,
    nb_vaches_lait: nbVachesLaitValidation,
    cooperative: z.boolean(),
    date_creation: dateCreationValidation,
    createdBy: z.string().min(1, "Le créateur est requis"),
  })
  .superRefine((data, ctx) => {
    // Cross-validation rules

    // 1. Validate province based on region
    const provinces = PROVINCE_BY_REGION[data.region];
    if (provinces && !provinces.includes(data.province)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Province non valide pour cette région",
        path: ["province"],
      });
    }

    // 2. Validate that nb_vaches_lait <= effectif_bovins
    if (data.nb_vaches_lait > data.effectif_bovins) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Le nombre de vaches laitières ne peut pas dépasser l'effectif total",
        path: ["nb_vaches_lait"],
      });
    }

    // 3. Validate that identifiant_responsable and eleveur_id are different
    if (data.identifiant_responsable === data.eleveur_id) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Le responsable et l'éleveur doivent être différents",
        path: ["eleveur_id"],
      });
    }
  });

// Update exploitation validation schema
export const UpdateExploitationValidationSchema = z
  .object({
    numero_exploitation: numeroExploitationValidation.optional(),
    nom_ferme: nameValidation.optional(),
    idbda_onssa: z
      .string()
      .min(5, "L'ID BDA ONSSA doit contenir au moins 5 caractères")
      .max(20, "L'ID BDA ONSSA ne peut pas dépasser 20 caractères")
      .optional(),
    identifiant_responsable: z.string().min(1, "Le responsable est requis").optional(),
    gerant: nameValidation.optional(),
    tel_contact: phoneValidation.optional(),
    email_contact: emailValidation.optional(),
    eleveur_id: z.string().min(1, "L'éleveur est requis").optional(),
    region: regionValidation.optional(),
    province: z.string().min(1, requiredMsg).optional(),
    adresse: addressValidation.optional(),
    location: locationValidation.optional(),
    sau: sauValidation.optional(),
    effectif_bovins: effectifBovinsValidation.optional(),
    nb_vaches_lait: nbVachesLaitValidation.optional(),
    cooperative: z.boolean().optional(),
    date_creation: dateCreationValidation.optional(),
  })
  .superRefine((data, ctx) => {
    // Cross-validation rules for updates (only validate if fields are present)

    // 1. Validate province based on region (if both are present)
    if (data.region && data.province) {
      const provinces = PROVINCE_BY_REGION[data.region];
      if (provinces && !provinces.includes(data.province)) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "Province non valide pour cette région",
          path: ["province"],
        });
      }
    }

    // 2. Validate that nb_vaches_lait <= effectif_bovins (if both are present)
    if (
      data.nb_vaches_lait !== undefined &&
      data.effectif_bovins !== undefined &&
      data.nb_vaches_lait > data.effectif_bovins
    ) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Le nombre de vaches laitières ne peut pas dépasser l'effectif total",
        path: ["nb_vaches_lait"],
      });
    }

    // 3. Validate that identifiant_responsable and eleveur_id are different (if both are present)
    if (
      data.identifiant_responsable &&
      data.eleveur_id &&
      data.identifiant_responsable === data.eleveur_id
    ) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Le responsable et l'éleveur doivent être différents",
        path: ["eleveur_id"],
      });
    }
  });

// Filter validation schema
export const ExploitationFiltersValidationSchema = z.object({
  numero_exploitation: z.string().optional(),
  nom_ferme: z.string().optional(),
  idbda_onssa: z.string().optional(),
  identifiant_responsable: z.string().optional(),
  gerant: z.string().optional(),
  region: z.string().optional(),
  province: z.string().optional(),
  cooperative: z.boolean().optional(),
  createdBy: z.string().optional(),
  dateCreation: z.string().optional(),
});

// Utility function to format validation errors
export const formatValidationErrors = (
  error: z.ZodError,
): Record<string, string> => {
  const formattedErrors: Record<string, string> = {};

  error.errors.forEach((err) => {
    const path = err.path.join(".");
    formattedErrors[path] = err.message;
  });

  return formattedErrors;
};

// Utility function to validate numéro exploitation format only
export const validateNumExploitationFormat = (numeroExploitation: string): boolean => {
  return NUM_EXPLOITATION_PATTERN.test(numeroExploitation.toUpperCase());
};

// Utility function to validate phone format only
export const validatePhoneFormat = (phone: string): boolean => {
  return PHONE_PATTERN.test(phone);
};

// Utility function to validate email format only
export const validateEmailFormat = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

// Utility function to get provinces for a region
export const getProvincesForRegion = (region: string): string[] => {
  return PROVINCE_BY_REGION[region] || [];
};

// Utility function to generate a sample numéro exploitation
export const generateSampleNumExploitation = (): string => {
  const randomNumber = Math.floor(Math.random() * 100000000)
    .toString()
    .padStart(8, "0");
  return `FR${randomNumber}`;
};

// Utility function to validate coordinates are in Morocco
export const validateMoroccanCoordinates = (coordinates: [number, number]): boolean => {
  const [lng, lat] = coordinates;
  return lng >= -17.2 && lng <= -0.99 && lat >= 21.42 && lat <= 35.92;
};

// Utility function to format coordinates for display
export const formatCoordinates = (coordinates: [number, number]): string => {
  const [lng, lat] = coordinates;
  return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
};

// Export types for TypeScript inference
export type CreateExploitationFormData = z.infer<
  typeof CreateExploitationValidationSchema
>;
export type UpdateExploitationFormData = z.infer<
  typeof UpdateExploitationValidationSchema
>;
export type ExploitationFiltersFormData = z.infer<
  typeof ExploitationFiltersValidationSchema
>;
export type Step1FormData = z.infer<typeof Step1ValidationSchema>;
export type Step2FormData = z.infer<typeof Step2ValidationSchema>;
export type Step3FormData = z.infer<typeof Step3ValidationSchema>;
export type Step4FormData = z.infer<typeof Step4ValidationSchema>;
export type Step5FormData = z.infer<typeof Step5ValidationSchema>;
