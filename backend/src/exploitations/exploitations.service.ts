import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import {
  Exploitation,
  ExploitationDocument,
} from './schemas/exploitation.schema';
import { Model, Types } from 'mongoose';
import { CreateExploitationDto } from './dto/create-exploitation.dto';
import * as ExcelJS from 'exceljs';
import { Parser } from 'json2csv';
import { Buffer } from 'buffer';
import { UpdateExploitationDto } from './dto/update-exploitation.dto';

export class ExploitationNotFoundException extends HttpException {
  constructor(id: string) {
    super(`Exploitation with ID (${id}) not found`, HttpStatus.NOT_FOUND);
  }
}

@Injectable()
export class ExploitationsService {
  constructor(
    @InjectModel(Exploitation.name)
    private readonly exploitationModel: Model<ExploitationDocument>,
  ) {}

  create(dto: CreateExploitationDto) {
    const location = {
      type: 'Point',
      coordinates: [dto.longitude, dto.latitude],
    };

    const newExploitation = new this.exploitationModel({
      ...dto,
      location,
    });

    return newExploitation.save();
  }

  async findAll(): Promise<Exploitation[]> {
    return this.exploitationModel
      .find()
      .populate('identifiant_responsable')
      .populate('eleveur_id')
      .exec();
  }

  async findAllByUser(eleveurId: string): Promise<Exploitation[]> {
    return this.exploitationModel.find({ eleveur_id: eleveurId });
  }
  async findAllByEleveur(eleveurId: string): Promise<Exploitation[]> {
    return this.exploitationModel.find({ eleveur_id: eleveurId }).exec();
  }
  async filterExploitations(
    filters: any,
    eleveurId?: string,
  ): Promise<Exploitation[]> {
    const query: any = {};

    if (eleveurId) query.eleveur_id = eleveurId;

    if (filters.numero_exploitation)
      query.numero_exploitation = filters.numero_exploitation;
    if (filters.nom_ferme)
      query.nom_ferme = { $regex: filters.nom_ferme, $options: 'i' };
    if (filters.idbda_ons_sa) query.idbda_ons_sa = filters.idbda_ons_sa;
    if (filters.identifiant_responsable)
      query.identifiant_responsable = filters.identifiant_responsable;
    if (filters.region) query.region = filters.region;
    if (filters.cooperative) query.cooperative = filters.cooperative === 'true';
    if (filters.gerant)
      query.gerant = { $regex: filters.gerant, $options: 'i' };
    if (filters.tel_contact) query.tel_contact = filters.tel_contact;
    if (filters.email_contact) query.email_contact = filters.email_contact;
    if (filters.sau) query.sau = Number(filters.sau);
    if (filters.sau_fourragere)
      query.sau_fourragere = Number(filters.sau_fourragere);
    if (filters.effectif_bovins)
      query.effectif_bovins = Number(filters.effectif_bovins);
    if (filters.nb_vaches_lait)
      query.nb_vaches_lait = Number(filters.nb_vaches_lait);
    if (filters.adresse)
      query.adresse = { $regex: filters.adresse, $options: 'i' };
    if (filters.latitude) query.latitude = Number(filters.latitude);
    if (filters.longitude) query.longitude = Number(filters.longitude);
    if (filters.created_by) query.created_by = filters.created_by;
    if (filters.modified_by) query.modified_by = filters.modified_by;

    if (filters.date_creation_start && filters.date_creation_end) {
      query.date_creation = {
        $gte: new Date(filters.date_creation_start),
        $lte: new Date(filters.date_creation_end),
      };
    }

    return this.exploitationModel.find(query).exec();
  }

  async exportExploitationsToCSV(eleveurId: string): Promise<string> {
    const exploitations = await this.exploitationModel
      .find({ eleveur_id: eleveurId })
      .lean();

    const parser = new Parser();
    return parser.parse(exploitations);
  }

  /** Export Excel des exploitations de l’éleveur */
  async exportExploitationsToExcel(eleveurId: string): Promise<Buffer> {
    const exploitations = await this.exploitationModel
      .find({ eleveur_id: eleveurId })
      .lean();

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Exploitations');

    if (exploitations.length > 0) {
      // Définir les colonnes à partir des clés du premier document
      worksheet.columns = Object.keys(exploitations[0]).map((key) => ({
        header: key,
        key,
        width: 20,
      }));

      // Ajouter chaque ligne
      exploitations.forEach((exp) => {
        worksheet.addRow(exp);
      });
    }

    const buffer = await workbook.xlsx.writeBuffer();
    // Force un Buffer Node.js correctement typé
    return Buffer.from(buffer);
  }

  async update(
    id: string,
    updateExploitationDto: UpdateExploitationDto,
  ): Promise<Exploitation> {
    if (!Types.ObjectId.isValid(id))
      throw new ExploitationNotFoundException(id);
    const exploitation = await this.exploitationModel.findByIdAndUpdate(
      id,
      updateExploitationDto,
      { new: true },
    );
    if (!exploitation) throw new ExploitationNotFoundException(id);
    return exploitation;
  }

  async remove(id: string): Promise<Exploitation> {
    if (!Types.ObjectId.isValid(id))
      throw new ExploitationNotFoundException(id);
    const exploitation = await this.exploitationModel.findByIdAndDelete(id);
    if (!exploitation) throw new ExploitationNotFoundException(id);
    return exploitation;
  }
}
